### คำแนะนำในการใช้ sesion, cookie, define():
1. Sessions
สำหรับข้อมูลผู้ใช้ (เช่น username, user ID, สิทธิ์การใช้งาน): Sessions เป็นตัวเลือกที่ดีที่สุด
ตัวอย่างการใช้งาน Session:
page1.php (หน้าเว็บเริ่มต้น session และเก็บค่า):
< ?php
session_start(); // เริ่มต้น session

$_SESSION['username'] = 'JohnDoe'; // เก็บ username ใน session
$_SESSION['user_id'] = 123;       // เก็บ user ID ใน session

echo "Session started and data stored.";
?>

page2.php (หน้าเว็บเรียกใช้ค่าจาก session):
< ?php
session_start(); // เริ่มต้น session (ในทุกหน้าที่ต้องการใช้ session)

if (isset($_SESSION['username'])) {
    $username = $_SESSION['username'];
    $userId = $_SESSION['user_id'];

    echo "Welcome, " . $username . "! (User ID: " . $userId . ")";
} else {
    echo "No session data found.";
}
?>

session_start() ควรถูกวางไว้ที่ บรรทัดบนสุด ของไฟล์ PHP ที่ จำเป็นต้องมีการเข้าถึงตัวแปร $_SESSION เท่านั้น ซึ่งโดยทั่วไปคือไฟล์ที่ทำหน้าที่เป็น "หน้าเว็บ" หรือ "ตัวจัดการคำสั่ง (Controller)" เช่น:
check_login.php: ต้องมี เพราะต้องเขียนข้อมูลลง $_SESSION หลัง Login สำเร็จ
dashboard.php: ต้องมี เพราะต้องอ่านข้อมูลจาก $_SESSION เพื่อตรวจสอบว่าผู้ใช้ล็อกอินแล้วหรือยัง และเพื่อแสดงชื่อผู้ใช้
profile.php: ต้องมี เพราะเป็นหน้าที่ต้องล็อกอินก่อนถึงจะเข้าได้
logout.php: ต้องมี เพราะต้องเข้าไปล้างค่าและทำลาย Session
login.php: อาจจะมี ถ้าคุณต้องการแสดงข้อความบางอย่างจาก Session (เช่น "คุณออกจากระบบเรียบร้อยแล้ว")

2. Cookies
สำหรับ preferences ของผู้ใช้ (เช่น theme, ภาษา, การตั้งค่าอื่นๆ): Cookies อาจจะเหมาะสมกว่า เพราะต้องการให้คงอยู่แม้ปิด browser
ตัวอย่างการใช้งาน Cookies:
set_cookie.php (หน้าเว็บตั้งค่า Cookie):
< ?php
$cookie_name = "user_preference";
$cookie_value = "dark_theme";
$cookie_expiry = time() + (86400 * 30); // Cookie มีอายุ 30 วัน

setcookie($cookie_name, $cookie_value, $cookie_expiry, "/"); // ตั้งค่า cookie

echo "Cookie set successfully.";
?>

get_cookie.php (หน้าเว็บเรียกใช้ค่าจาก Cookie):
< ?php
if (isset($_COOKIE["user_preference"])) {
    $preference = $_COOKIE["user_preference"];
    echo "User preference: " . $preference;
} else {
    echo "Cookie 'user_preference' is not set.";
}
?>

3. define
สำหรับค่า configuration ของระบบ (เช่น URL เว็บไซต์, ข้อมูล database): Constants เป็นทางเลือกที่ดี เพราะเป็นค่าที่ไม่เปลี่ยนแปลง และต้องการให้เข้าถึงได้ง่ายจากทุกส่วนของโค้ด
การกำหนด Constant: ใช้ฟังก์ชัน define()
< ?php
define("SITE_URL", "https://www.example.com");
define("DB_HOST", "localhost");
define("DB_USER", "username");
define("DB_PASSWORD", "password");

echo "Site URL: " . SITE_URL;
echo "<br>Database Host: " . DB_HOST;
?>

สำหรับข้อมูลที่ต้องแชร์ระหว่างผู้ใช้ หรือข้อมูลจำนวนมากที่ต้องการ persistence: Database เป็นสิ่งที่หลีกเลี่ยงไม่ได้ */

?>

// แสดงผล SQL พร้อมค่าพารามิเตอร์
    echo "<pre>";
    $stmt->debugDumpParams();
    echo "</pre>";

// เริ่มต้น Output Buffering
    ob_start();
    $stmt->debugDumpParams();
    // รับเนื้อหาจาก Buffer และเก็บไว้ในตัวแปร
    $_SESSION['last_executed_sql'] = ob_get_clean();

    // คุณสามารถดูค่าใน Session ได้โดย:
    // echo "<pre>";
    // print_r($_SESSION);
    // echo "</pre>";

///////////////////////////////////////////////////////////////////////
การใช้ includes ในการตรวจสอบว่ามีค่านั้นๆหรือไม่ ใช้ได้กับ string หรือ Array เช่น
const fruits=['apple','banana','mango'];
fruits.includes('banana'); //จะได้ผลลัพธ์เป็น true 

'hello world'.includes('world'); //จะได้ผลลัพธ์เป็น true

///////////////////////////////////////////////////////////////////////
//************** fetch() และ fetchAll() **************//
 เป็นเมธอดของ PDOStatement object ใน PHP ที่ใช้สำหรับดึงข้อมูลจากชุดผลลัพธ์ (result set) ที่ได้จากการ execute คำสั่ง SQL

ความแตกต่างหลักๆ คือ:
fetch():
- ดึงข้อมูล ทั้งแถว(เพียง 1 row ทุก columns) ออกมาในรูปแบบของอาร์เรย์ (array) หรืออ็อบเจกต์ (object)
- หากไม่มีแถวข้อมูลเหลืออยู่ จะคืนค่า false
- โดยทั่วไปจะใช้ภายในลูป while เพื่อดึงข้อมูลทีละแถวจนกว่าจะหมด

fetchAll():
- ดึงข้อมูล ทั้งหมด ที่เหลืออยู่ในชุดผลลัพธ์
- คืนค่าเป็น อาร์เรย์ (array) ที่มีข้อมูลทุกแถว
- แต่ละแถวในอาร์เรย์จะเป็นอาร์เรย์หรืออ็อบเจ็กต์ ขึ้นอยู่กับค่า fetch_style ที่ระบุ

fetchColumn() 
- ดึงข้อมูล แค่คอลัมน์เดียว และส่งค่ากลับมาเป็น string หรือตัวเลขโดยตรงของผลลัพธ์ที่ได้จากการ query เช่น ผลรวม, จำนวนนับ, หรือ ID เดียว
- เหมาะสมที่สุดเมื่อผลลัพธ์ที่คุณคาดหวังคือ ข้อมูลเพียงค่าเดียว เช่น:
    - เมื่อใช้ฟังก์ชัน COUNT(), SUM(), AVG(), MAX(), MIN()
    - เมื่อต้องการดึง ID ล่าสุด (SELECT MAX(id) ...)
    - เมื่อต้องการดึงชื่อ, อีเมล, หรือข้อมูลใดๆ เพียงฟิลด์เดียวจาก 1 record (SELECT name FROM users WHERE id = ?)

ตัวอย่างการใช้งาน:
- สมมติว่าเรามีตาราง users ที่มีคอลัมน์ id และ username
<?php
$stmt = $pdo->query("SELECT id, username FROM users");

// ใช้ fetch() ดึงข้อมูลทีละแถว
echo "<h2>ใช้ fetch():</h2>";
while ($row = $stmt->fetch(PDO::FETCH_ASSOC)) {
    echo "ID: " . $row['id'] . ", Username: " . $row['username'] . "<br>";
}

// Reset cursor (จำเป็นหากต้องการดึงข้อมูลอีกครั้งด้วยวิธีอื่น)
$stmt->execute();

// ใช้ fetchAll() ดึงข้อมูลทั้งหมด
echo "<h2>ใช้ fetchAll():</h2>";
$results = $stmt->fetchAll(PDO::FETCH_ASSOC);
foreach ($results as $row) {
    echo "ID: " . $row['id'] . ", Username: " . $row['username'] . "<br>";
}
?>

//ใช้ fetchColumn()
$stmt = $pdo->prepare("SELECT COUNT(*) FROM events");
$stmt->execute();
$count = $stmt->fetchColumn(); // ได้ผลลัพธ์เป็นค่า 15 โดยตรง
echo "มีทั้งหมด " . $count . " งาน";

สรุป:
- ใช้ fetch() เมื่อต้องการประมวลผลข้อมูลทีละแถว เช่น แสดงข้อมูลจำนวนมาก หรือต้องการควบคุมการดึงข้อมูลอย่างละเอียด
- ใช้ fetchAll() เมื่อต้องการดึงข้อมูลทั้งหมดเข้าสู่อาร์เรย์ในครั้งเดียว เหมาะสำหรับชุดข้อมูลขนาดเล็กถึงปานกลาง และต้องการนำข้อมูลไปประมวลผลต่อในรูปแบบอาร์เรย์
- ใช้ fetchColumn() เมื่อต้องการข้อมูลเพียงค่าเดียว

ข้อควรระวัง:
- การใช้ fetchAll() กับชุดข้อมูลขนาดใหญ่อาจทำให้ใช้หน่วยความจำมาก เนื่องจากข้อมูลทั้งหมดจะถูกโหลดเข้าสู่หน่วยความจำพร้อมกัน 
- ในกรณีนี้ การใช้ fetch() ภายในลูปอาจมีประสิทธิภาพมากกว่า
- หลังจากใช้ fetchAll() แล้ว ตัวชี้ (cursor) ของ PDOStatement จะอยู่ที่ตำแหน่งสุดท้ายของชุดผลลัพธ์ 
- หากต้องการดึงข้อมูลอีกครั้งด้วย fetch() หรือ fetchAll() จะต้อง execute คำสั่ง SQL ใหม่อีกครั้ง หรือใช้เมธอดอื่นเพื่อเลื่อนตัวชี้กลับไป (ซึ่งบางไดรเวอร์ของ PDO อาจไม่รองรับ)

///////////////////////////////////////////////////////////////////////
★★★ หัวใจสำคัญคือความแตกต่างในการคืนค่าระหว่าง fetch() และ fetchAll() เมื่อไม่พบข้อมูล:

$stmt->fetch():
- เมื่อเจอข้อมูล: คืนค่าเป็น array ของแถวนั้น
- เมื่อไม่เจอข้อมูล (หรืออ่านจนหมดแล้ว): คืนค่าเป็น false
- ดังนั้น: ใน checkLogin() เราจึงต้องมี if ($user_data) เพื่อตรวจสอบก่อน เพราะผลลัพธ์อาจเป็น array หรือ false

ถ้าต้องการให้ข้อมูลที่ได้เป็น false เปลี่ยนเป็น Null แทนสามารถทำได้ 3 วิธี ดังนี้
1. ใช้ Elvis Operator (?:) ซึ่งเป็นวิธีที่สั้นและทันสมัยที่สุด(เป็นการเขียนย่อของ Ternary Operator)
    $rs = $stmt->fetch(PDO::FETCH_ASSOC) ?: null;
2. ใช้ Ternary Operator แบบเต็ม
    $result = $stmt->fetch(PDO::FETCH_ASSOC);
    $rs = $result ? $result : null;
3. ใช้ If-Else แบบปกติ (ชัดเจนที่สุด)
    $result = $stmt->fetch(PDO::FETCH_ASSOC);
    if ($result === false) {
        $rs = null;
    } else {
        $rs = $result;
    }

$stmt->fetchAll():
- เมื่อเจอข้อมูล (แม้จะแค่ 1 แถว): คืนค่าเป็น array ของ array (array ที่มีข้อมูลของทุกแถวซ้อนอยู่ข้างใน)
- เมื่อไม่เจอข้อมูลเลย: คืนค่าเป็น array ว่าง (empty array [])
- ข้อสังเกต: fetchAll() จะ ไม่คืนค่าเป็น false เมื่อไม่พบข้อมูล มันจะคืนค่าเป็น array เสมอ แค่เป็น array ที่ไม่มีสมาชิกเท่านั้น
ด้วยเหตุนี้ การเขียนฟังก์ชัน getAllRecords จึงไม่จำเป็นต้องตรวจสอบค่าก่อน return เพราะผลลัพธ์ที่ได้เป็นประเภทข้อมูลที่สม่ำเสมอ (คือเป็น array เสมอ)
การตรวจสอบค่าที่เรียกใช้: if (!empty($allUsers)) หรือ if (count($allUsers) > 0)

///////////////////////////////////////////////////////////////////////
คำสั่ง LIMIT ใน MySQL ใช้สำหรับ จำกัดจำนวนแถว ที่จะถูกส่งคืนโดยคำสั่ง SELECT 
ช่วยควบคุมขนาดของชุดผลลัพธ์ โดยมักใช้ร่วมกับ ORDER BY เพื่อให้ได้ผลลัพธ์ที่แน่นอน 
และใช้ในเทคนิคการแบ่งหน้าข้อมูล (pagination) เพื่อดึงข้อมูลทีละหน้า โดยไวยากรณ์คือ 
SELECT ... FROM ... LIMIT [offset,] count. 
หลักการทำงาน
LIMIT count: กำหนดจำนวนแถวสูงสุดที่จะส่งคืน เช่น LIMIT 10 จะส่งคืน 10 แถวแรก. 
LIMIT offset, count: กำหนดทั้งจำนวนแถวที่จะข้าม (offset) และจำนวนแถวที่จะส่งคืน (count). 
offset: คือจำนวนแถวที่ต้องการข้ามไปก่อน (เริ่มนับจาก 0). 
count: คือจำนวนแถวที่ต้องการแสดงหลังจากการข้าม. 

///////////////////////////////////////////////////////////////////////
★★★ ดึงค่าจาก radio button ที่ถูก ":checked" ของ row ★★★
const radioButtons = document.querySelectorAll('input[name="disbursement"]');
let disbursement = 0; // กำหนดค่าเริ่มต้นเป็น 0
for (const radioButton of radioButtons) {
    if (radioButton.checked) {
    disbursement = radioButton.value; // ดึงค่าจาก value
    break;
    }
}

หรือ

ใช้ [name^="disbursement"] เพื่อเลือก radio button ทั้งหมดที่ชื่อขึ้นต้นด้วย "disbursement"
    
///////////////////////////////////////////////////////////////////////

array_filter คือฟังก์ชันมาตรฐานของ PHP ที่ทำหน้าที่เหมือน "กระชอน" หรือ "ตะแกรงร่อน" สำหรับ Array ครับ
หน้าที่หลัก: คือการ "กรอง" สมาชิกใน Array เดิม เพื่อสร้าง Array ใหม่ที่มีเฉพาะสมาชิกที่ "ผ่านเงื่อนไข" ที่เรากำหนดเท่านั้น
วิธีการทำงาน:
มันจะรับ Array ที่เราต้องการกรองเข้ามาเป็น Input แรก
มันจะรับ "ฟังก์ชันสำหรับตรวจสอบเงื่อนไข" (เรียกว่า Callback Function) เข้ามาเป็น Input ที่สอง
มันจะวนลูปสมาชิกทุกตัวใน Array แรก แล้วส่งสมาชิกแต่ละตัวเข้าไปใน "ฟังก์ชันตรวจสอบเงื่อนไข"
ถ้าฟังก์ชันตรวจสอบ คืนค่า true: สมาชิกตัวนั้นจะ "ผ่าน" และถูกเก็บไว้ใน Array ใหม่
ถ้าฟังก์ชันตรวจสอบ คืนค่า false: สมาชิกตัวนั้นจะ "ไม่ผ่าน" และถูกทิ้งไป

ตัวอย่างการใช้งาน
$numbers = [1, 2, 3, 4, 5, 6];

// ใช้ array_filter กับฟังก์ชันแบบปกติ
$evenNumbers = array_filter($numbers, function($number) {
    // ถ้า $number หาร 2 ลงตัว ให้คืนค่า true (ผ่าน)
    // ถ้าไม่ ก็จะคืนค่า false โดยปริยาย (ไม่ผ่าน)
    return $number % 2 == 0;
});

// ผลลัพธ์ที่ได้คือ Array ใหม่ที่มีแค่เลขคู่
// print_r($evenNumbers); 
// Output: 
// Array
// (
//     [1] => 2
//     [3] => 4
//     [5] => 6
// )

///////////////////////////////////////////////////////////////////////
วิธีมาตรฐาน (Standard Practice) ในการสื่อสารกับ AJAX
header('Content-Type: application/json');
echo json_encode($return_value);
*** คือหัวใจสำคัญของการสร้าง API ที่จะส่งข้อมูลกลับไปให้ฝั่ง Frontend (JavaScript/AJAX)

1. header('Content-Type: application/json');
หน้าที่: เป็นการ "ติดป้าย" บอกเบราว์เซอร์หรือโค้ดที่เรียกใช้ (AJAX) ว่า "ข้อมูลที่ฉันกำลังจะส่งคืนไปให้นี้ ไม่ใช่หน้าเว็บ HTML ทั่วไปนะ แต่เป็นข้อมูลในรูปแบบ JSON"
ประโยชน์: เมื่อ AJAX ได้รับการตอบกลับ (Response) มันจะรู้ทันทีว่าต้องจัดการข้อมูลนี้ในรูปแบบ JSON 
ทำให้ Library อย่าง jQuery หรือ fetch API ของ JavaScript สามารถแปลงข้อมูลกลับเป็น JavaScript Object ได้โดยอัตโนมัติและง่ายดาย

2. echo json_encode($response_array);
หน้าที่: แปลงข้อมูลของฝั่ง PHP (ซึ่งมักจะเป็น Array หรือ Object) ให้อยู่ในรูปแบบ "ข้อความ" (String) ที่มีโครงสร้างแบบ JSON
ประโยชน์: JavaScript ไม่สามารถเข้าใจโครงสร้าง Array ของ PHP ได้โดยตรง แต่ ทั้ง PHP และ JavaScript เข้าใจภาษา JSON เหมือนกัน 
JSON จึงทำหน้าที่เป็น "ภาษากลาง" ในการแลกเปลี่ยนข้อมูลระหว่าง Server (PHP) และ Client (JavaScript)

การนำไปใช้งานที่ถูกต้อง (Separation of Concerns)
    สิ่งสำคัญคือต้องวางโค้ด 2 บรรทัดนี้ให้ถูกที่ครับ มันไม่ควรอยู่ใน Class (user_class) แต่ควรอยู่ในไฟล์ที่ทำหน้าที่เป็น API Endpoint (ไฟล์ที่ AJAX เรียกมา)

สรุปหลักการทำงาน
1. แยกความรับผิดชอบชัดเจน: 
    - user_class สนใจแค่ "วิธีการ" จัดการข้อมูลในฐานข้อมูล
    - manage_user.php สนใจแค่ "จะทำอะไร" (เช่น รับค่าจากฟอร์มแล้วส่งต่อให้ user_class)

2. ใช้ Prepared Statements: 
    - ทุกเมธอดที่ยุ่งกับข้อมูล (INSERT, UPDATE, DELETE) ใช้ prepare() และส่งค่าเข้าไปผ่าน array ใน execute() เพื่อป้องกัน SQL Injection อย่างสมบูรณ์

3. Hasing รหัสผ่าน: 
    ในเมธอด create() มีการใช้ password_hash() ก่อนเสมอ เป็นขั้นตอนที่ห้ามลืมเด็ดขาด

4. คืนค่าที่มีความหมาย:
    - create() คืนค่า lastInsertId() เพื่อให้เรารู้ว่าผู้ใช้ใหม่ที่สร้างมี ID อะไร สามารถนำไปใช้ต่อได้ทันที
    - update() และ delete() คืนค่าเป็น boolean (true/false) เพื่อบอกสถานะความสำเร็จให้โค้ดที่เรียกใช้ทราบได้ง่ายๆ

////////////////////////////////////////////////////////////////////////////
"Post/Redirect/Get" (PRG) ซึ่งเป็นมาตรฐานสำหรับเว็บแอปพลิเคชันทั่วไปที่ไม่มี AJAX
    ถ้าไม่ได้ใช้ AJAX สองบรรทัดนั้น ไม่จำเป็นต้องใช้เลย

การทำงานเมื่อไม่มี AJAX (Traditional Form Submission)
    เป้าหมายจะเปลี่ยนไปครับ แทนที่จะส่งข้อมูลกลับไปให้ JavaScript เพื่ออัปเดตหน้าเดิม 
เราจะประมวลผลคำสั่ง แล้วส่งผู้ใช้ไปยังหน้าใหม่(หรือหน้าเดิมที่โหลดใหม่) พร้อมกับข้อความแจ้งสถานะ

หลักการทำงาน (Post/Redirect/Get):
1. POST: ผู้ใช้กรอกฟอร์มและกด "Submit" เบราว์เซอร์จะส่งข้อมูลไปยังไฟล์ PHP ที่กำหนดใน action ของฟอร์ม (เช่น process_delete_user.php)
2. PROCESS: ไฟล์ process_delete_user.php ทำงาน
    - เรียกใช้เมธอดจาก Class (เช่น $userRepo->delete($userId))
    - เมธอดคืนค่า true หรือ false
    - (จุดสำคัญ) นำผลลัพธ์ที่ได้ไปเก็บใน $_SESSION เพื่อใช้แสดงผลในหน้าถัดไป
3. REDIRECT: ไฟล์ process_delete_user.php จะไม่แสดงผลอะไรออกมาเลย 
แต่จะใช้คำสั่ง header('Location: ...') เพื่อสั่งให้เบราว์เซอร์ "เปลี่ยนหน้า" ไปยังหน้าที่เราต้องการ (เช่น กลับไปหน้ารายชื่อผู้ใช้ user_list.php)
4. GET: เบราว์เซอร์ได้รับคำสั่ง Redirect และทำการร้องขอ (Request) หน้า user_list.php ใหม่
5. DISPLAY: หน้า user_list.php จะตรวจสอบค่าใน $_SESSION ที่เราเก็บไว้ ถ้ามีข้อความแจ้งสถานะ ก็จะดึงมาแสดงผลให้ผู้ใช้เห็น 
จากนั้นก็ลบค่าออกจาก Session เพื่อไม่ให้แสดงซ้ำในการโหลดหน้าครั้งต่อไป

///////////////////////////////////////////////////////////////////////////////
: ?array 
    คือการประกาศว่า "ฟังก์ชันนี้จะคืนค่าเป็น array หรือ null เท่านั้น"
มันเป็นการบังคับเลยว่าฟังก์ชันนี้ ห้ามคืนค่า false, string, หรือ int โดยเด็ดขาด

/////////////////////////////////////////////////////////////////////////////////
// การตั้งค่าสำหรับตอนพัฒนา
ini_set('display_errors', 1);
error_reporting(E_ALL);

// การตั้งค่าสำหรับตอนใช้งานจริง (Production)

// 1. ปิดการแสดงผล Error บนหน้าจอ (สำคัญมาก!)
ini_set('display_errors', 0);

// 2. ยังคงให้ PHP รายงาน Error ทุกอย่างเหมือนเดิม
error_reporting(E_ALL);

// 3. แต่สั่งให้ไป "บันทึก" ลงในไฟล์ Log แทน
ini_set('log_errors', 1);
ini_set('error_log', '/path/to/your/php-errors.log'); // ★★★ แก้ไข Path ให้ถูกต้อง และควรอยู่นอก Web Root เพื่อความปลอดภัย



ความหมาย
ให้ PHP รายงานข้อผิดพลาดทุกอย่าง และแสดงผลมันออกมาบนหน้าจอทั้งหมด
1. error_reporting(E_ALL);
- error_reporting(): เป็นฟังก์ชันสำหรับตั้งค่า "ระดับ" ของข้อผิดพลาดที่เราต้องการให้ PHP สนใจและรายงานผล
- E_ALL: เป็นค่าคงที่ (Constant) ที่หมายถึง "All" หรือ "ทั้งหมด"
- ความหมายรวม: "บอกให้ PHP ช่วยจับตาดูและรายงานข้อผิดพลาด, คำเตือน (Warning), และข้อสังเกต (Notice) ทุกประเภทที่เกิดขึ้น ไม่ว่าจะเป็นเรื่องเล็กหรือใหญ่ก็ตาม"

2. ini_set('display_errors', 1);
- ini_set(): เป็นฟังก์ชันสำหรับแก้ไขค่าการตั้งค่าของ PHP (ที่ปกติจะอยู่ในไฟล์ php.ini) ชั่วคราวเฉพาะตอนที่สคริปต์นี้ทำงาน
- 'display_errors': คือชื่อของการตั้งค่าที่ควบคุมว่า "จะแสดงข้อผิดพลาดที่เจอบนหน้าจอหรือไม่"
- 1: มีความหมายเหมือนกับ "On" หรือ "เปิดใช้งาน"
- ความหมายรวม: "หลังจากที่ error_reporting เจอข้อผิดพลาดแล้ว ให้สั่งปรินต์ข้อผิดพลาดนั้นออกมาบนหน้าจอเบราว์เซอร์ให้เห็นด้วย"

////////////////////////////////////////////////////////////////////////////////
// สังเกตเครื่องหมาย & หน้า $period
$periods = $this->getOrderPeriodsByOrderId($id);
foreach ($periods as &$period) {
    // การแก้ไข $period จะมีผลกับข้อมูลต้นทางใน $periods โดยตรง
    $period['tasks'] = $this->getTasksByPeriodId($period['id']);
}
$order['periods'] = $periods;
// เป็น best practice ที่ควร unset reference หลังจบ loop
unset($period);
คำอธิบายการเปลี่ยนแปลง:
1. หลังจากดึงข้อมูล periods ทั้งหมดมาได้แล้ว เราไม่ได้ใส่เข้าไปใน $order ทันที
2. เราใช้ foreach เพื่อวนลูป periods ทีละรายการ
3. ในแต่ละรอบของลูป เราเรียกใช้ฟังก์ชัน getTasksByPeriodId() ที่สร้างขึ้นใหม่ โดยส่ง id ของ Period ปัจจุบันเข้าไป
4. ผลลัพธ์ (ซึ่งเป็น array ของ Tasks) จะถูกเก็บไว้ใน key ใหม่ชื่อว่า 'tasks' ของ Period นั้นๆ
5. เมื่อวนลูปครบทุก Period แล้ว เราจะได้ array $periods ที่สมบูรณ์ (แต่ละ Period มีรายการ Tasks ของตัวเอง) จากนั้นจึงนำไปใส่ใน $order['periods']

เช่น
1. ดึงข้อมูล period ทั้งหมดของ order ที่กำหนด -> ตรงนี้จะได้จำนวน period หลาย period ของ order นี้
2. ในแต่ละ period ต้องดึง task ของตัวเองมาเก็บไว้ที่ $period['tasks']
โดยทำการ Loop $periods (สมมติว่ามี 3 period)
รอบที่ 1 นำ task ของ period ที่ 1 มาใส่ใน period ที่ 1
รอบที่ 2 นำ task ของ period ที่ 2 มาใส่ใน period ที่ 2
รอบที่ 3 นำ task ของ period ที่ 3 มาใส่ใน period ที่ 3
โดยแต่ละ task จะเป็น array ที่ดึงมาจาก DB ตาม period ที่ระบุ

////////////////////////////////////////////////////////////////////////
การจัดเก็บข้อมูลที่เป็น array ลงในฟิลด์ TEXT ใน mySql
// ข้อมูลที่จะ insert
$product_name = "Laptop รุ่นใหม่";
$product_features_array = ["หน้าจอ 15 นิ้ว", "RAM 16GB", "SSD 512GB", "Wi-Fi 6"];

// แปลง array เป็น JSON string
$product_features_json = json_encode($product_features_array, JSON_UNESCAPED_UNICODE);

// SQL query สำหรับ insert
$sql = "INSERT INTO products (name, features) VALUES (?, ?)";

// เตรียม statement
$stmt = $conn->prepare($sql);

// bind parameters
$stmt->bind_param("ss", $product_name, $product_features_json);

// execute query
$stmt->execute()
/////////////////////////////////////////////////////////////////////////////

Class
ไม่จำเป็นต้องมี __construct ในทุกคลาส
จะใช้ __construct ก็ต่อเมื่อเราต้องการ "บังคับ" หรือ "มีงานให้ทำ" ตอนสร้าง Object โดยให้มีการกำหนดค่าเริ่มต้นหรือทำงานบางอย่าง 
ทันทีที่ Object ถูกสร้างขึ้นด้วยคำสั่ง new เช่น การกำหนดค่าเริ่มต้น หรือการเชื่อมต่อฐานข้อมูล

การใช้ static เหมาะกับงานที่เป็น "ฟังก์ชันช่วย" (Utility Functions) ที่ไม่มีสถานะเป็นของตัวเอง เช่น Math::calculate(...)

/////////////////////////////////////////////////////////////////////////////

fetchObject() 
    เป็นเมธอดของ PDO ที่ใช้ดึงข้อมูลแถวถัดไปจากผลลัพธ์การ query แล้วส่งค่ากลับมาเป็น Object แทนที่จะเป็น Array 
โดยมันจะนำชื่อคอลัมน์ในฐานข้อมูลมาจับคู่กับชื่อ Public Property ของคลาสที่เรากำหนดโดยอัตโนมัติ

## ⚙️ ขั้นตอนการทำงาน (How it Works)
เมื่อเราสั่ง $stmt->fetchObject('User') จะเกิดกระบวนการ 4 ขั้นตอนหลักๆ ดังนี้:

1. สร้าง Object ใหม่: PDO จะสร้าง Object ว่างๆ ขึ้นมาหนึ่งตัวจากคลาสที่เราส่งชื่อเข้าไป (เช่น class 'User') 
    หากเราไม่ระบุชื่อคลาส มันจะสร้าง Object จากคลาสมาตรฐาน stdClass ให้แทน

2. ดึงข้อมูล 1 แถว: มันจะดึงข้อมูลจากฐานข้อมูลมา 1 แถว (เหมือน fetch())

3. จับคู่ข้อมูล (Mapping): ✨ นี่คือหัวใจสำคัญ ✨ PDO จะวนดูข้อมูลที่ได้มาทีละคอลัมน์ 
    แล้วนำค่าไปใส่ใน Public Property ของ Object ที่มีชื่อตรงกันทุกประการ
    ถ้าเจอคอลัมน์ชื่อ id ในฐานข้อมูล -> มันจะมองหา $user->id แล้วนำค่าไปใส่
    ถ้าเจอคอลัมน์ชื่อ full_name ในฐานข้อมูล -> มันจะมองหา $user->full_name แล้วนำค่าไปใส่

4. เรียก Constructor (ถ้ามี): หลังจากที่กำหนดค่าให้ Properties ทั้งหมดเรียบร้อยแล้ว 
    มันจะเรียกเมธอด __construct() ของคลาสนั้นเป็นลำดับสุดท้าย (นี่เป็นจุดที่แตกต่างจากการ new ปกติ)

ตัวอย่างคลาส User.php
class User {
    public $id;
    public $username;
    public $full_name;

    public function getGreeting() {
        return "Hello, " . $this->full_name;
    }
}

SQL Query
---------
$stmt = $pdo->prepare("SELECT id, username, full_name FROM users WHERE id = 1");
$stmt->execute();

แบบที่ 1: fetch() แบบปกติ (ได้ Array)
$user_array = $stmt->fetch(PDO::FETCH_ASSOC);
print_r($user_array);
/*ผลลัพธ์
Array
(
    [id] => 1
    [username] => admin
    [full_name] => Admin User
)
*/
// การเข้าถึงข้อมูล
echo $user_array['full_name']; // ผลลัพธ์: Admin User
ข้อสังเกต: ได้ข้อมูลเป็น Array ธรรมดา ไม่สามารถเรียกใช้เมธอดได้

แบบที่ 2: fetchObject() (ได้ Object)
$user_object = $stmt->fetchObject('User');
print_r($user_object);
/*ผลลัพธ์
User Object
(
    [id] => 1
    [username] => admin
    [full_name] => Admin User
)
*/
// การเข้าถึงข้อมูล (ง่ายกว่า)
echo $user_object->full_name; // ผลลัพธ์: Admin User
// สามารถเรียกใช้เมธอดของคลาสได้ทันที
echo $user_object->getGreeting(); // ผลลัพธ์: Hello, Admin User

## ✅ ข้อดีของ fetchObject
1. โค้ดสะอาด อ่านง่าย: การใช้ $object->property ดูเป็นธรรมชาติและสื่อความหมายได้ดีกว่า $array['key']
2. ได้ Object ที่มี Type ชัดเจน: โปรแกรมแก้ไขโค้ด (IDE) จะรู้ว่า $user_object เป็น Object ประเภท User ทำให้สามารถช่วยเติมโค้ด (Autocomplete) และตรวจสอบข้อผิดพลาดได้
3. ต่อยอดได้: Object ที่ได้มาสามารถมีเมธอด (พฤติกรรม) เป็นของตัวเองได้ ไม่ได้เป็นแค่ที่เก็บข้อมูลเฉยๆ

## ⚠️ ข้อควรระวัง
1. Property ต้องเป็น public: fetchObject ไม่สามารถกำหนดค่าให้กับ Property ที่เป็น private หรือ protected ได้
2. ชื่อต้องตรงกัน: ชื่อคอลัมน์ในฐานข้อมูลและชื่อ Property ในคลาสต้องสะกดตรงกันทุกตัวอักษร (Case-Sensitive)
3. Constructor ทำงานทีหลัง: ลำดับการทำงานคือ กำหนดค่า Property ก่อน แล้วจึงเรียก __construct() 
    ซึ่งหมายความว่าถ้าใน __construct() ของคุณมีการเรียกใช้ Property ใดๆ ค่าของมันจะยังไม่ถูกกำหนดจากฐานข้อมูลในขณะนั้น
/////////////////////////////////////////////////////////////////////////////

การเปลี่ยนจาก fetch มาเป็น fetchObject
1. สร้างคลาส Order (และคลาส Period ถ้าต้องการ)
    สร้างคลาส Order โดยคลาส Order ต้องมี property (ที่เป็น public) เพื่อรอรับข้อมูล periods 
    class Order {
        // Properties ที่ตรงกับคอลัมน์ในตาราง orders
        public ?int $id = null;
        public ?string $order_number = null;
        public ?string $customer_name = null;
        // ... ใส่ property อื่นๆ ให้ครบ ...

        // ✨ Property นี้สำหรับเก็บข้อมูล periods ที่จะดึงมาทีหลัง
        public array $periods = []; 
    }

2. สร้างคลาส Period
    class Period {
        public ?int $id = null;
        public ?int $order_id = null;
        public ?string $due_date = null;
        public ?float $amount = null;
        // ... property อื่นๆ ของ period ...
    }

3. สร้างคลาส OrderRepository 
    <?php
    // สมมติว่านี่คือคลาส Repository หรือ Service
    class OrderRepository 
    {
        private $pdo;

        public function __construct(PDO $pdo) {
            $this->pdo = $pdo;
        }

        /**
        * เมธอดที่ปรับปรุงใหม่: คืนค่าเป็น Order object หรือ null
        */
        public function getOrderById(int $id): ?Order
        {
            $stmt = $this->pdo->prepare("SELECT * FROM orders WHERE id = ?");
            $stmt->execute([$id]);

            // ดึงข้อมูลมาเป็น Object ของคลาส Order
            $order = $stmt->fetchObject('Order');

            // ตรวจสอบว่าหา Order เจอหรือไม่
            if ($order) {
                // ถ้าเจอ, ให้ไปดึงข้อมูล periods มาใส่ใน property ของ object
                $periods = $this->getOrderPeriodsByOrderId($id);
                $order->periods = $periods;
            }

            // คืนค่าเป็น Order object ที่มีข้อมูล periods อยู่ข้างใน หรือคืนค่า null ถ้าหาไม่เจอ
            return $order;
        }

        /**
        * เมธอดที่ปรับปรุงใหม่: คืนค่าเป็น array ของ Period objects
        * @return Period[]
        */
        private function getOrderPeriodsByOrderId(int $order_id): array
        {
            $stmt = $this->pdo->prepare("SELECT * FROM order_periods WHERE order_id = ?");
            $stmt->execute([$order_id]);

            // ดึงข้อมูลทั้งหมดมาเป็น array ของ Object คลาส Period
            return $stmt->fetchAll(PDO::FETCH_CLASS, 'Period');
        }
    }

ตัวอย่างการใช้งาน
// สมมติว่าได้สร้าง object ของ Repository ไว้แล้ว
$orderRepo = new OrderRepository($pdo_connection);

$order_id = 123;
$order = $orderRepo->getOrderById($order_id);

if ($order) {
    // เข้าถึงข้อมูลหลักของ Order ได้โดยตรง
    echo "Order Number: " . $order->order_number;
    echo "Customer: " . $order->customer_name;

    // วนลูปแสดงข้อมูลงวดชำระ (periods)
    if (!empty($order->periods)) {
        echo "<h3>Payment Periods:</h3>";
        echo "<ul>";
        foreach ($order->periods as $period) {
            // $period คือ Object ของคลาส Period
            echo "<li>Due Date: {$period->due_date}, Amount: {$period->amount}</li>";
        }
        echo "</ul>";
    } else {
        echo "<p>No payment periods found for this order.</p>";
    }

} else {
    echo "Order with ID {$order_id} not found.";
}

/////////////////////////////////////////////////////////////////////////////
mPDF ก็สามารถสั่งขึ้นหน้าใหม่ได้ 2 แบบนี้
<?php
require_once __DIR__ . '/vendor/autoload.php';
$mpdf = new \Mpdf\Mpdf();

// หน้าแรก
$mpdf->WriteHTML('<h1>หน้าแรก</h1><p>เนื้อหา...</p>');

// สั่งขึ้นหน้าใหม่
$mpdf->AddPage();

// หน้าใหม่
$mpdf->WriteHTML('<h1>หน้าที่สอง</h1><p>เนื้อหาเพิ่มเติม...</p>');

// อีกวิธี: ใช้ pagebreak
$html = '
<h1>หน้านี้ก่อน break</h1>
<pagebreak />
<h1>หน้านี้หลัง break</h1>
';
$mpdf->WriteHTML($html);

$mpdf->Output();

// กำหนด Header และ Footer ให้แสดงทุกหน้า
// ✅ Header
$mpdf->SetHTMLHeader('
<table width="100%">
    <tr>
        <td width="15%"><img src="logo.png" height="40"></td>
        <td width="85%" style="text-align: left;">
            <strong>บริษัท ตัวอย่าง จำกัด</strong><br>
            123 ถนนสุขุมวิท แขวงคลองเตย กรุงเทพฯ 10110
        </td>
    </tr>
</table>
<hr>
');

// ✅ Footer
$mpdf->SetHTMLFooter('
<div style="border-top:1px solid #000; font-size:9pt; text-align: center; padding-top:5px;">
    © 2025 Example Co.,Ltd. — หน้า {PAGENO} / {nb}
</div>
');

โดยที่
{PAGENO} = เลขหน้าปัจจุบัน
{nb} = จำนวนหน้าทั้งหมด

// ✅ โหลดไฟล์ CSS
$stylesheet = file_get_contents('style.css');→ โหลดไฟล์ CSS
$mpdf->WriteHTML($stylesheet, 1);  // 1 = CSS → ต้องใส่ 1 เพื่อบอกว่าเป็น CSS ไม่ใช่ HTML

/////////////////////////////////////////////////////////////////////////////
## ❌ ปัญหา: การซ้อน Transaction (Nested Transactions)
ปัญหาหลักคือ การพยายามเริ่ม Transaction ใหม่ (beginTransaction()) ในขณะที่ยังมี Transaction เดิมทำงานอยู่ บน PDO Connection เดียวกัน
ตามลำดับการทำงานที่ต้องการ:
1. โค้ดภายนอกเรียก class_1->save()
2. class_1->save() เรียก $this->db->beginTransaction()  (Transaction เริ่มต้นที่นี่)
3.INSERT INTO table_1 สำเร็จ
4. ภายใน try ของ class_1 คุณเรียก class_2->save()
5. class_2->save() จะพยายามเรียก $this->db->beginTransaction() อีกครั้ง
หมายเหตุ: ณ จุดนี้ PDO จะโยน Exception (PDOException) ออกมาทันที พร้อมข้อความประมาณว่า "There is already an active transaction" 
เพราะไดรเวอร์ฐานข้อมูลส่วนใหญ่ (รวมถึง MySQL) ไม่รองรับการซ้อน Transaction ในลักษณะนี้

## ✅ แนวทางแก้ไขที่ถูกต้อง
เราต้องปรับโครงสร้างโค้ดใหม่ โดยยึดหลักการว่า "Transaction ควรถูกควบคุมจากที่เดียว และอยู่ชั้นนอกสุดของการทำงานที่ต้องการให้เป็น Atomic"

### วิธีที่ 1: แยกส่วนจัดการ Transaction ออกมา (วิธีแนะนำ 👍)
เป็นวิธีที่ดีที่สุด (Best Practice) เพราะทำให้แต่ละ Class ทำหน้าที่ของตัวเองอย่างเดียว (Single Responsibility) และโค้ดโดยรวมจัดการง่ายกว่า

ขั้นตอนที่ 1: ปรับแก้ Class 1 และ Class 2
นำส่วนจัดการ Transaction (beginTransaction, commit, rollBack) ออกจากฟังก์ชัน save() ให้ฟังก์ชันนี้ทำหน้าที่แค่ INSERT ข้อมูลอย่างเดียว

class_1 {
    // ... constructor รับ $db ...

    // ฟังก์ชันนี้รับผิดชอบแค่การ insert ลง table_1
    public function save(array $data) {
        $sql = "INSERT INTO table_1...";
        $stmt = $this->db->prepare($sql);
        $stmt->execute($data);
        return $this->db->lastInsertId();
    }
}

class_2 {
    // ... constructor รับ $db ...

    // ฟังก์ชันนี้รับผิดชอบแค่การ insert ลง table_2
    public function save(array $data) {
        $sql = "INSERT INTO table_2...";
        $stmt = $this->db->prepare($sql);
        $stmt->execute($data);
        return $this->db->lastInsertId();
    }
}

ขั้นตอนที่ 2: สร้าง Controller หรือ Service เพื่อจัดการการทำงาน
สร้างโค้ดอีกส่วนหนึ่ง (อาจเป็น Class ใหม่ เช่น RegistrationService หรือเป็นแค่ไฟล์สคริปต์) เพื่อควบคุมลำดับการทำงานและจัดการ Transaction ทั้งหมด

// --- ไฟล์ process.php หรือ RegistrationService.php ---

// สมมติว่าสร้าง PDO connection และ class object ไว้แล้ว
// และทั้ง $class1 และ $class2 ใช้ PDO connection ตัวเดียวกัน
$db = Database::getInstance()->getConnection();
$class1 = new Class_1($db);
$class2 = new Class_2($db);

// ข้อมูลที่จะบันทึก
$data1 = ['name' => 'Test'];
$data2_template = ['action' => 'CREATED'];

// 💡 ควบคุม Transaction ที่นี่ที่เดียว!
try {
    // 1. เริ่ม Transaction
    $db->beginTransaction();

    // 2. เรียกใช้ฟังก์ชัน save ของ class 1
    $table1_id = $class1->save($data1);

    // 3. เตรียมข้อมูลและเรียกใช้ฟังก์ชัน save ของ class 2
    $data2 = $data2_template;
    $data2['table1_ref_id'] = $table1_id; // ใช้ ID จาก table 1
    $class2->save($data2);

    // 4. ถ้าทุกอย่างผ่านหมด ให้ commit
    $db->commit();
    echo "✅ Success: ข้อมูลทั้ง 2 ตารางถูกบันทึกเรียบร้อย";

} catch (Exception $e) {
    // 5. หากมีข้อผิดพลาดใดๆ เกิดขึ้น ให้ rollBack
    if ($db->inTransaction()) {
        $db->rollBack();
    }
    echo "❌ Error: การบันทึกข้อมูลล้มเหลว " . $e->getMessage();
    // throw $e; // หรือโยน exception ต่อไปตามความเหมาะสม
}

/////////////////////////////////////////////////////////////////////////////
ฟังก์ชัน pathinfo() จะแยกส่วนประกอบทั้งหมดของ path ออกมาเก็บในรูปแบบ array
ตัวอย่าง
$fullPath = 'Upload/images/filename.jpg';

// แยกส่วนประกอบทั้งหมด
$pathParts = pathinfo($fullPath);

/*
$pathParts จะกลายเป็น Array แบบนี้:
[
    'dirname' => 'Upload/images',      // ชื่อไดเรกทอรี
    'basename' => 'filename.jpg',      // ชื่อไฟล์เต็ม (รวมนามสกุล)
    'extension' => 'jpg',              // นามสกุลไฟล์
    'filename' => 'filename'           // ชื่อไฟล์ (ไม่รวมนามสกุล)
]
*/

basename() และ dirname() ฟังก์ชันสำหรับการแยก "ชื่อไฟล์" และ "พาธ" ออกจากกันโดยตรง
basename(): ดึงเอาเฉพาะส่วน ชื่อไฟล์และนามสกุล ออกมาจาก path เต็ม
dirname(): ดึงเอาเฉพาะส่วน ไดเรกทอรี (พาธ) ออกมาจาก path เต็ม

ตัวอย่าง
$fullPath = 'Upload/images/filename.jpg';

// 1. ดึงเฉพาะชื่อไฟล์
$fileName = basename($fullPath); // ผลลัพธ์: 'filename.jpg'

// 2. ดึงเฉพาะพาธของไดเรกทอรี
$directoryPath = dirname($fullPath); // ผลลัพธ์: 'Upload/images'

/////////////////////////////////////////////////////////////////////////////
URL.createObjectURL() คือ เมธอดของ JavaScript ที่ใช้สร้าง URL ชั่วคราว (blob URL) 
เพื่ออ้างอิงถึง ไฟล์หรือข้อมูลในหน่วยความจำ (Blob หรือ File object) โดยไม่ต้องอัปโหลดไฟล์ขึ้นเซิร์ฟเวอร์ก่อน

🔹 การใช้งานหลัก
1. ใช้แสดงไฟล์ที่ผู้ใช้เลือกจาก <input type="file"> เช่น แสดงรูปภาพหรือเล่นวิดีโอ
2. ใช้ดาวน์โหลดไฟล์ที่สร้างจาก JavaScript (เช่นไฟล์ที่ generate ขึ้นมาเอง)
3. ใช้กับ <img>, <video>, <a download> หรือ API อื่น ๆ ที่ต้องการ URL

🔹 Syntax
const url = URL.createObjectURL(object);
- object → ต้องเป็น Blob หรือ File
- คืนค่าเป็น string URL เช่น blob:http://localhost:3000/df91f65d-xxxx-xxxx-xxxx

🔹 ตัวอย่าง 1: แสดงรูปที่เลือกจาก <input type="file">
<input type="file" id="fileInput">
<img id="preview" width="200">

<script>
document.getElementById('fileInput').addEventListener('change', function(event) {
  const file = event.target.files[0];   // เอาไฟล์แรก
  if (file) {
    const imgUrl = URL.createObjectURL(file); // สร้าง blob URL
    document.getElementById('preview').src = imgUrl;
  }
});
</script>

🔹 ตัวอย่าง 2: สร้างและดาวน์โหลดไฟล์จาก Blob
<button id="download">Download Text File</button>

<script>
document.getElementById('download').addEventListener('click', function() {
  const blob = new Blob(["Hello World!"], { type: "text/plain" });
  const url = URL.createObjectURL(blob);

  const a = document.createElement("a");
  a.href = url;
  a.download = "example.txt";
  a.click();

  URL.revokeObjectURL(url); // ลบ URL ที่ไม่ใช้แล้ว (ป้องกัน memory leak)
});
</script>

🔹 หมายเหตุสำคัญ

blob URL ใช้ได้เฉพาะใน session ของ browser ที่สร้างขึ้นมา (ไม่สามารถ copy ไปใช้ใน browser อื่นได้)
ควรเรียก URL.revokeObjectURL(url) เมื่อไม่ใช้งานแล้ว เพื่อคืนหน่วยความจำ

สรุป : 
URL.createObjectURL() = ทำให้ Blob/File ใช้งานเหมือน URL จริง ๆ ได้ (เช่น <img src="">, <a href="">) โดยไม่ต้องอัปโหลดไฟล์ขึ้นเซิร์ฟเวอร์ก่อน

/////////////////////////////////////////////////////////////////////////////
เมื่อ browser ส่ง form ไปหา server ถ้ามี 
1. <input type="file"> ใน <form></form> หรือ
2. มีการใช้ FormData แล้วแนบไฟล์เข้าไป (เช่น formData.append("file", selectedFile) โดย selectedFile คือไฟล์จริง)

👉 browser จะส่ง request แบบ multipart/form-data ไป ไม่ใช่ application/x-www-form-urlencoded แบบฟอร์มธรรมดา

/////////////////////////////////////////////////////////////////////////////
$result = [ 
    'header' => $rsPoHeader, 
    'details' => $rsPoDetails, 
    'plan_status' => $rsPlanStatus, 
]; 
echo json_encode($result);
ถ้า $rsPlanStatus เป็น NULL หมายความว่าจะไม่มีทางรู้จักฟิลด์ status_name ดังนั้นถ้าต้องการไม่ให้เกิด error สามารถทำได้ดังนี้
1. ${data.plan_status ? data.plan_status.plan_status_name : ''}
2. ${data.plan_status ?.status_name || ''}

/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

◽